# Structure/Flow Mutation

This folder contains the code for the structure/flow mutation experiment in Section 5. The structure/flow mutation experiment involves finding the third parties on a site that are classified as ATS (Ad and Tracking Service) by the classifier, and performing different types of changes to the structure of the site that targets the structure/flow features. Please read the paper for more details. To run this task, please run the following script with relevant arguments (example below):

```
python greedy_mutation.py
```
> The arguments accepted by this script:
>
> --config Path to a config.yaml where all the configuration parameters have to be set for the experiment. We provide a [sample file](https://github.com/spring-epfl/WebGraph/blob/main/robustness/structure_mutation/config.yaml) for reference. 

Pre-requisites:

Before running this code, you need to run the WebGraph pipeline to obtain graph files and classification (since mutations occur based on existing classifier predictions). You also need a trained model file to test how well the mutation performs (so run [classify.py](https://github.com/spring-epfl/WebGraph/blob/main/code/classification/classify.py) with `--save True`.

Example script run:
```
python greedy_mutation.py --config config.yaml
```
The `config.yaml` file contains the following parameters that have to be set:

> graph_data: Path to a graph.csv file generated by the WebGraph graph creation process. This is the graph data to be mutated.
>
> content_ldb: Path to the content.ldb folder generated from the OpenWPM crawl. We need this for feature extraction.
>
> feature_config: Path to the feature configuration file. Sample file [here](https://github.com/spring-epfl/WebGraph/blob/main/code/features.yaml). We need this for feature extraction.
>
> vid_file: Path to a JSON file containing a list of visit IDs for which we want to perform the mutation. Example in `sample/chosen_ids.json`
>
> filterlists: Path to an output folder to which filter lists will be downloaded for labelling.
>
> parent_limit: Number of nodes to act as start points to perform mutation. Note: Increasing the parent_limit will increase experiment run time.
>
> model: Path to a trained model file generated the WebGraph classification process (these are files labelled `model_0.joblib`, `model_1.joblib`, etc.). Example in `sample/model_1.joblib`.
>
> result_dir: Path to output folder for the result.
>
> mutation_style: Select any (min: 1, max: 4) kind of mutation from the list: [node_addition, storage_removal, redirect_removal, url_obfuscation]. 

### Pipeline

The pipeline performs the following tasks:

1. Reads the input graph file, trained model, and selected visit IDs.
2. Obtains original predictions of the classifier for the selected visit IDs.
3. Reads the input predictions file to get all the third party nodes classified as ATS by the classifier.  Find the third party with the largest number of ATS nodes, this is the adversary whose predictions we will attempt to switch.
4. Perform content_mutation on the nodes in the graph. We assume the worst case that the adversary already does content mutation before attempting structure/flow mutation. 
5. Check predictions after content mutation. These predictions act as the baseline (i.e., the adversary tries to flip these predictions). 
6. Perform structure/flow mutation via a greedy algorithm as follows (which will go for a number of iterations, currently calculated as 20% of the original graph size):
	a. Get a set of the adversary's nodes that will act as start points for the mutation, let us call these `starts`.
	b. For each `start` node, perform every mutation set in the config file. There are 4 kinds of mutation. `node_addition` adds a random child node to the `start`. `storage_removal` reduces any cookie/local storage accesses performed by `start` (to simulate merging of cookies). `redirect_removal` redistributes redirects from `start` into multiple non-redirect requests. `url_obfuscation` checks if `start` has any cookie value in its URL and randomizes this (to simulate using an encoding not considered by the classifier). 
	c. After each mutation, calculate switches in predictions to all nodes in the graph (ATS to non-ATS and vice versa). 
	d. Select the mutation with the best desired/undesired trade-off for the adversary. 
	e. Redo the algorithm with the new graph (which has the selected mutation applied). 

#### Output
During the experiment, one of the files in the result directory `diff_stats` will provide the switches at each iteration (which can be used for any analysis). Example line from this file:

```Iteration: 20 Diff: -2 Desired: 0 Undesired: 2 ad_adv_content_adv: 0 ad_others_content_others: 0 ad_tp_content_tp: 0 ad_fp_content_fp: 0 content_others_ad_others: 1 content_tp_ad_tp: 1 content_fp_ad_fp: 0 content_adv_ad_adv: 1```

> Iteration: Iteration number
> 
> Diff: Difference between desired and undesired switches
> 
> Desired: Number of desired switches
> 
> Undesired: Number of undesired switches
> 
> ad_adv_content_adv: Number of adversary nodes that switched prediction from ATS to non-ATS
> 
> ad_others_content_others: Number of non-adversary nodes that switched prediction from ATS to non-ATS
> 
> ad_tp_content_tp: Number of non-adversary third party nodes that switched prediction from ATS to non-ATS
> 
> ad_fp_content_fp: Number of non-adversary first party nodes that switched prediction from ATS to non-ATS
> 
> content_others_ad_others: Number of non-adversary nodes that switched prediction from non-ATS to ATS
> 
> content_tp_ad_tp: Number of non-adversary third party nodes that switched prediction from non-ATS to ATS
> 
> content_fp_ad_fp: Number of non-adversary first party nodes that switched prediction from non-ATS to ATS
> 
> content_adv_ad_adv: Number of adversary nodes that switched prediction from non-ATS to ATS
